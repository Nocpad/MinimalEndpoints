using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Text;

namespace MinimalEndpoints.SourceGenerator;


[Generator]
public sealed class IncrementalSourceGenerator : IIncrementalGenerator
{
    private static string _namespace = "";
    private const string EndpointAttribute = "Nocpad.AspNetCore.MinimalEndpoints.EndpointAttribute";
    private const string EndpointWithGroupAttribute = "Nocpad.AspNetCore.MinimalEndpoints.EndpointAttribute`1";
    private const string EndpointWithConfiguration = "Nocpad.AspNetCore.MinimalEndpoints.IEndpointConfiguration";


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        Debugger.Launch();
#endif

        RegisterPostInitialization(context);

        //var @namespace = context.AnalyzerConfigOptionsProvider.Select((a, _) => a.GlobalOptions.TryGetValue("build_property.rootnamespace", out var rootNamespace) ? rootNamespace : null);

        IncrementalValuesProvider<Endpoint> endpoints = context.SyntaxProvider.ForAttributeWithMetadataName(
            EndpointAttribute,
            predicate: (_, _) => true,
            transform: GetSemanticTargetForGeneration
        ).Where(static m => m is not null)!;

        IncrementalValuesProvider<Endpoint> endpointsWithGroup = context.SyntaxProvider.ForAttributeWithMetadataName(
            EndpointWithGroupAttribute,
            predicate: (_, _) => true,
            transform: GetSemanticTargetForGeneration
        ).Where(static m => m is not null)!;

        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(compilation.Combine(endpoints.Collect()), static (spc, source) => Execute(source, spc, "MapIndividualEndpoints", "Individual"));

        context.RegisterSourceOutput(compilation.Combine(endpointsWithGroup.Collect()), static (spc, source) => Execute(source, spc, "MapEndpointGroups", "Groups"));

        //context.RegisterImplementationSourceOutput(compilation.Combine(endpoints.Collect()), (spc, content) =>
        //{
        //    //spc.AddSource()
        //    // do the full, expensive generation
        //});
    }


    private static void Execute((Compilation Left, ImmutableArray<Endpoint> Right) source, SourceProductionContext spc, string implementingMethod, string hintName)
    {
        StringBuilder sb = new(1024);

        (Compilation compilation, ImmutableArray<Endpoint> endpoints) = source;


        sb.Append($$"""
            // <auto-generated />
            using Microsoft.AspNetCore.Builder;

            public static partial class MapMinimalEndpointsExtensions
            {
                public static partial void {{implementingMethod}}(this WebApplication app)
                {
  
            """);

        AddEndpointsWithoutGroup(endpoints, sb);

        sb.Append("""
                }
            }
            """);

        spc.AddSource($"MapMinimalEndpointsExtensions.{hintName}.g.cs", sb.ToString());
    }


    private static void AddEndpointsWithoutGroup(ImmutableArray<Endpoint> endpoints, StringBuilder sb)
    {
        foreach (var item in endpoints)
        {
            sb.Append($"""
                        //{item}
                """)
              .AppendLine();
        }
    }


    static Endpoint? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return null;
        }

        ct.ThrowIfCancellationRequested();

        var classMembers = classSymbol.GetMembers();

        foreach (var member in classMembers)
        {
            if (member is not IMethodSymbol method)
            {
                continue;
            }

            var attributes = method.GetAttributes();

            foreach (var attribute in attributes)
            {
                var httpMethod = $"{attribute.AttributeClass.ContainingNamespace.ToDisplayString()}.{attribute.AttributeClass.Name}" switch
                {
                    "Nocpad.AspNetCore.MinimalEndpoints.DeleteAttribute" => "DELETE",
                    "Nocpad.AspNetCore.MinimalEndpoints.GetAttribute" => "GET",
                    "Nocpad.AspNetCore.MinimalEndpoints.PostAttribute" => "POST",
                    "Nocpad.AspNetCore.MinimalEndpoints.PutAttribute" => "PUT",
                    _ => null
                };

                if (httpMethod is null)
                {
                    continue;
                }


                var endpointAttribute = ((ClassDeclarationSyntax)context.TargetNode).AttributeLists[0].Attributes[0];
                var activeArgument = endpointAttribute.ArgumentList?.Arguments.FirstOrDefault(arg => arg.NameEquals?.Name.Identifier.Text == "Active");
                bool activeValue = activeArgument?.Expression is not LiteralExpressionSyntax literalExpression || (bool)literalExpression.Token.Value!;

                EndpointNamespace? groupNamespace = null;

                if (endpointAttribute.Name is GenericNameSyntax genericNameSyntax)
                {
                    var typeInfo = context.SemanticModel.GetTypeInfo(genericNameSyntax.TypeArgumentList.Arguments[0]).Type;
                    groupNamespace = new(typeInfo.ContainingNamespace, typeInfo.Name);
                }

                return new Endpoint
                {
                    IsActive = activeValue,
                    HasConfiguration = classSymbol.AllInterfaces.Any(e => $"{e.ContainingNamespace.ToDisplayString()}.{e.Name}" == EndpointWithConfiguration),
                    EndpointMethod = member.Name,
                    HttpMethod = httpMethod,
                    Namespace = new(method.ContainingNamespace, classSymbol.Name),
                    Template = attribute.ConstructorArguments[0].Value?.ToString()!,
                    GroupNamespace = groupNamespace,
                };
            }
        }

        return null;
    }


    private static void RegisterPostInitialization(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(async ctx =>
        {
            var httpAttriteTempate = await GetSourceFileTemplate("HttpMethodAttribute.template", null);
            string[] verbs = ["Get", "Post", "Put", "Delete"];

            foreach (var verb in verbs)
            {
                ctx.AddSource($"{verb}Attribute.g.cs", SourceText.From(httpAttriteTempate.Replace("{{METHOD}}", verb), Encoding.UTF8));
            }

            ctx.AddSource("EndpointInterfaces.g.cs", SourceText.From(await GetSourceFileTemplate("Interfaces.template", null), Encoding.UTF8));
            ctx.AddSource("EndpointAttribute.g.cs", SourceText.From(await GetSourceFileTemplate("EndpointAttribute.template", null), Encoding.UTF8));

            ctx.AddSource("MapMinimalEndpointsExtensions.g.cs", $$"""
                // <auto-generated />
                using Microsoft.AspNetCore.Builder;

                public static partial class MapMinimalEndpointsExtensions
                {
                    public static WebApplication MapMinimalEndpoints(this WebApplication app)
                    {
                        MapIndividualEndpoints(app);
                        MapEndpointGroups(app);

                        return app;
                    }

                    public static partial void MapIndividualEndpoints(this WebApplication app);

                    public static partial void MapEndpointGroups(this WebApplication app);
                } 
                """);
        });
    }


    private static async Task<string> GetSourceFileTemplate(string resourceName, string outputNamespace)
    {
        var assembly = Assembly.GetExecutingAssembly();
        string resourcePath = assembly
            .GetManifestResourceNames()
            .FirstOrDefault(e => e.Contains(resourceName));

        using Stream stream = assembly.GetManifestResourceStream(resourcePath);
        using StreamReader reader = new(stream);

        var content = await reader.ReadToEndAsync();

        // TODO: allow overriding the namespace of each source file
        return content.Replace("{{GeneratorNamespace}}", outputNamespace ?? "Nocpad.AspNetCore.MinimalEndpoints");
    }
}


record Endpoint
{
    public bool IsActive { get; set; }

    public string Template { get; set; } = string.Empty;

    public string EndpointMethod { get; set; } = string.Empty;

    public string HttpMethod { get; set; } = string.Empty;

    public EndpointNamespace Namespace { get; set; } = null!;

    public bool HasConfiguration { get; set; }

    public EndpointNamespace? GroupNamespace { get; set; }
}



record EndpointNamespace
{
    public EndpointNamespace(INamespaceSymbol @namespace, string groupName)
    {
        Value = $"{(@namespace.IsGlobalNamespace ? "global::" : @namespace.ToDisplayString() + ".")}{groupName}";
    }

    public string Value { get; private set; }

    public override string ToString() => Value;
}