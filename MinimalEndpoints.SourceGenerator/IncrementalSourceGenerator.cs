using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Text;

namespace MinimalEndpoints.SourceGenerator;


[Generator]
public sealed class IncrementalSourceGenerator : IIncrementalGenerator
{
    private static string _namespace = "";
    private const string EndpointAttribute = "Nocpad.AspNetCore.MinimalEndpoints.EndpointAttribute";
    private const string EndpointWithGroupAttribute = "Nocpad.AspNetCore.MinimalEndpoints.EndpointAttribute`1";
    private const string EndpointWithConfiguration = "Nocpad.AspNetCore.MinimalEndpoints.IEndpointConfiguration";


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
//#if DEBUG
//        Debugger.Launch();
//#endif

        RegisterPostInitialization(context);

        //var @namespace = context.AnalyzerConfigOptionsProvider.Select((a, _) => a.GlobalOptions.TryGetValue("build_property.rootnamespace", out var rootNamespace) ? rootNamespace : null);

        IncrementalValuesProvider<Endpoint> endpoints = context.SyntaxProvider.ForAttributeWithMetadataName(
            EndpointAttribute,
            predicate: (_, _) => true,
            transform: GetSemanticTargetForGeneration
        ).Where(static m => m is not null)!;

        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(compilation.Combine(endpoints.Collect()), static (spc, source) => Execute(source, spc));

        //context.RegisterImplementationSourceOutput(endpoints.Collect(), (spc, content) =>
        //{
        //    //spc.AddSource()
        //    // do the full, expensive generation
        //});
    }

    private static void Execute((Compilation Left, ImmutableArray<Endpoint> Right) source, SourceProductionContext spc)
    {
        StringBuilder sb = new(1024);

        (Compilation compilation, ImmutableArray<Endpoint> endpoints) = source;

        sb.Append("""
            // <auto-generated />
            using Microsoft.AspNetCore.Builder;

            public static partial class MapMinimalEndpointsExtensions
            {
                public static partial void MapMinimalEndpoints(this WebApplication app)
                {

            """);

        AddEndpointsWithoutGroup(endpoints, sb);

        sb.Append("""

                }
            }
            """);

        spc.AddSource("MapMinimalEndpointsExtensionsImpl.g.cs", sb.ToString());
    }


    private static void AddEndpointsWithoutGroup(ImmutableArray<Endpoint> endpoints, StringBuilder sb)
    {
        foreach (var item in endpoints)
        {
            sb.Append($"""
                        //{item}
                """)
              .AppendLine();
        }
    }

    static bool IsSyntaxTargetForGeneration(SyntaxNode node) => node is ClassDeclarationSyntax c && c.AttributeLists.Count > 0;


    static Endpoint? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return null;
        }

        ct.ThrowIfCancellationRequested();

        var classMembers = classSymbol.GetMembers();

        foreach (var member in classMembers)
        {
            if (member is not IMethodSymbol method)
            {
                continue;
            }

            var attributes = method.GetAttributes();

            foreach (var attribute in attributes)
            {
                var httpMethod = $"{attribute.AttributeClass.ContainingNamespace.ToDisplayString()}.{attribute.AttributeClass.Name}" switch
                {
                    "Nocpad.AspNetCore.MinimalEndpoints.DeleteAttribute" => "DELETE",
                    "Nocpad.AspNetCore.MinimalEndpoints.GetAttribute" => "GET",
                    "Nocpad.AspNetCore.MinimalEndpoints.PostAttribute" => "POST",
                    "Nocpad.AspNetCore.MinimalEndpoints.PutAttribute" => "PUT",
                    _ => null
                };

                if (httpMethod is null)
                {
                    continue;
                }

                var genericNameSyntax = ((ClassDeclarationSyntax)context.TargetNode).AttributeLists[0].Attributes[0].Name as GenericNameSyntax;

                return new Endpoint
                {
                    HasConfiguration = classSymbol.AllInterfaces.Any(e => $"{e.ContainingNamespace.ToDisplayString()}.{e.Name}" == EndpointWithConfiguration),
                    HttpMethod = httpMethod,
                    Namespace = method.ContainingNamespace.IsGlobalNamespace ? "global::" : method.ContainingNamespace.ToDisplayString(),
                    Template = attribute.ConstructorArguments[0].Value?.ToString(),
                    //EndpointGroupType = genericNameSyntax is null "",
                };
            }
        }

        return null;
    }


    private static void RegisterPostInitialization(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(async ctx =>
        {
            var httpAttriteTempate = await GetSourceFileTemplate("HttpMethodAttribute.template", null);
            string[] verbs = ["Get", "Post", "Put", "Delete"];

            foreach (var verb in verbs)
            {
                ctx.AddSource($"{verb}Attribute.g.cs", SourceText.From(httpAttriteTempate.Replace("{{METHOD}}", verb), Encoding.UTF8));
            }

            ctx.AddSource("EndpointInterfaces.g.cs", SourceText.From(await GetSourceFileTemplate("Interfaces.template", null), Encoding.UTF8));
            ctx.AddSource("EndpointAttribute.g.cs", SourceText.From(await GetSourceFileTemplate("EndpointAttribute.template", null), Encoding.UTF8));

            ctx.AddSource("MapMinimalEndpointsExtensions.g.cs", $$"""
                // <auto-generated />
                using Microsoft.AspNetCore.Builder;
                
                public static partial class MapMinimalEndpointsExtensions
                {
                    public static partial void MapMinimalEndpoints(this WebApplication app);
                } 
                """);
        });
    }


    private static async Task<string> GetSourceFileTemplate(string resourceName, string outputNamespace)
    {
        var assembly = Assembly.GetExecutingAssembly();
        string resourcePath = assembly
            .GetManifestResourceNames()
            .FirstOrDefault(e => e.Contains(resourceName));

        using Stream stream = assembly.GetManifestResourceStream(resourcePath);
        using StreamReader reader = new(stream);

        var content = await reader.ReadToEndAsync();

        // TODO: allow overriding the namespace of each source file
        return content.Replace("{{GeneratorNamespace}}", outputNamespace ?? "Nocpad.AspNetCore.MinimalEndpoints");
    }
}


record Endpoint
{
    public string Template { get; set; } = string.Empty;

    public string HttpMethod { get; set; } = string.Empty;

    public string Namespace { get; set; } = string.Empty;

    public INamedTypeSymbol? EndpointGroupType { get; set; }

    public bool HasConfiguration { get; set; }

}