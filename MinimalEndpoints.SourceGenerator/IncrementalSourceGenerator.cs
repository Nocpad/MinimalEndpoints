using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Text;

namespace MinimalEndpoints.SourceGenerator;


[Generator]
public sealed class IncrementalSourceGenerator : IIncrementalGenerator
{
    private static string _namespace = "";
    private const string EndpointAttribute = "Nocpad.AspNetCore.MinimalEndpoints.EndpointAttribute";
    private const string EndpointWithGroupAttribute = "Nocpad.AspNetCore.MinimalEndpoints.EndpointAttribute`1";
    private const string EndpointWithConfiguration = "Nocpad.AspNetCore.MinimalEndpoints.IEndpointConfiguration";


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        Debugger.Launch();
#endif

        RegisterPostInitialization(context);

        IncrementalValuesProvider<Endpoint> endpoints = context.SyntaxProvider.ForAttributeWithMetadataName(
            EndpointAttribute,
            predicate: (_, _) => true,
            transform: GetSemanticTargetForGeneration
        ).Where(static m => m is not null)!;

        IncrementalValuesProvider<Endpoint> endpointsWithGroup = context.SyntaxProvider.ForAttributeWithMetadataName(
            EndpointWithGroupAttribute,
            predicate: (_, _) => true,
            transform: GetSemanticTargetForGeneration
        ).Where(static m => m is not null)!;

        var compilation = context.CompilationProvider;

        context.RegisterSourceOutput(compilation.Combine(endpoints.Collect()), static (spc, source) => Execute(source, spc, "MapIndividualEndpoints", "Individual"));

        context.RegisterSourceOutput(compilation.Combine(endpointsWithGroup.Collect()), static (spc, source) => Execute(source, spc, "MapEndpointGroups", "Groups"));

        //context.RegisterImplementationSourceOutput(compilation.Combine(endpoints.Collect()), (spc, content) =>
        //{
        //    //spc.AddSource()
        //    // do the full, expensive generation
        //});
    }


    private static void Execute((Compilation Left, ImmutableArray<Endpoint> Right) source, SourceProductionContext spc, string implementingMethod, string hintName)
    {
        StringBuilder sb = new(1024);

        (Compilation compilation, ImmutableArray<Endpoint> endpoints) = source;

        var hasGroup = endpoints is { Length: > 0 } && endpoints[0].Group is not null;

        var groupedEndpoints = endpoints.GroupBy(e => e.Group?.Route);

        sb.Append($$"""
            // <auto-generated />
            using Microsoft.AspNetCore.Builder;

            public static partial class MapMinimalEndpointsExtensions
            {
                public static partial void {{implementingMethod}}(this WebApplication app)
                {
  
            """);

        if (!hasGroup)
        {
            AddEndpointsWithoutGroup(endpoints, sb);
        }
        else
        {
            sb.AppendLine("");
        }

        sb.Append("""
                }
            }
            """);

        spc.AddSource($"MapMinimalEndpointsExtensions.{hintName}.g.cs", sb.ToString());
    }


    private static void AddEndpointsWithoutGroup(ImmutableArray<Endpoint> endpoints, StringBuilder sb)
    {
        int counter = 1;
        foreach (var item in endpoints)
        {
            if (!item.IsActive)
            {
                continue;
            }

            var endpointVariableName = $"endpoint{counter++}";

            item.AppenEndpointString(sb, "app", endpointVariableName);

            sb.AppendLine();
        }
    }


    static Endpoint? GetSemanticTargetForGeneration(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (context.TargetSymbol is not INamedTypeSymbol classSymbol)
        {
            return null;
        }

        ct.ThrowIfCancellationRequested();

        var classMembers = classSymbol.GetMembers();

        foreach (var member in classMembers)
        {
            if (member is not IMethodSymbol method)
            {
                continue;
            }

            var attributes = method.GetAttributes();

            foreach (var attribute in attributes)
            {
                var httpMethod = $"{attribute.AttributeClass.ContainingNamespace.ToDisplayString()}.{attribute.AttributeClass.Name}" switch
                {
                    "Nocpad.AspNetCore.MinimalEndpoints.DeleteAttribute" => "DELETE",
                    "Nocpad.AspNetCore.MinimalEndpoints.GetAttribute" => "GET",
                    "Nocpad.AspNetCore.MinimalEndpoints.PostAttribute" => "POST",
                    "Nocpad.AspNetCore.MinimalEndpoints.PutAttribute" => "PUT",
                    _ => null
                };

                if (httpMethod is null)
                {
                    continue;
                }

                var endpointAttribute = ((ClassDeclarationSyntax)context.TargetNode).AttributeLists[0].Attributes[0];

                var activeArgument = endpointAttribute.ArgumentList?.Arguments.FirstOrDefault(arg => arg.NameEquals?.Name.Identifier.Text == "Active");
                bool activeValue = activeArgument?.Expression is not LiteralExpressionSyntax literalExpression || (bool)literalExpression.Token.Value!;

                return new Endpoint
                {
                    IsActive = activeValue,
                    HasConfiguration = classSymbol.AllInterfaces.Any(e => $"{e.ContainingNamespace.ToDisplayString()}.{e.Name}" == EndpointWithConfiguration),
                    EndpointMethod = member.Name,
                    HttpMethod = httpMethod,
                    Namespace = new(method.ContainingNamespace, classSymbol.Name),
                    Template = attribute.ConstructorArguments[0].Value?.ToString()!,
                    Group = TryGetGroup(endpointAttribute, context),
                };
            }
        }

        return null;
    }


    static Group? TryGetGroup(AttributeSyntax endpointAttribute, GeneratorAttributeSyntaxContext context)
    {
        Group? endpointGroup = null;

        if (endpointAttribute.Name is GenericNameSyntax genericNameSyntax)
        {
            endpointGroup = new();

            var typeInfo = context.SemanticModel.GetTypeInfo(genericNameSyntax.TypeArgumentList.Arguments[0]).Type!;
            var syntaxTree = typeInfo.Locations.First().SourceTree;
            var root = syntaxTree!.GetRoot();

            endpointGroup.Namespace = new(typeInfo!.ContainingNamespace, typeInfo.Name);

            var groupMembers = typeInfo.GetMembers();

            foreach (var m in groupMembers)
            {
                if (m is not IPropertySymbol propertySymbol)
                {
                    continue;
                }

                if (propertySymbol.Name is "Name" or "Route")
                {

                    var propertyDeclaration = root.DescendantNodes().OfType<PropertyDeclarationSyntax>().FirstOrDefault(p => p.Identifier.Text == propertySymbol.Name);

                    if (propertyDeclaration.Initializer?.Value is not null)
                    {
                        endpointGroup.Name = GetInitializerPropertyValue<string>(context.SemanticModel.Compilation, propertyDeclaration, propertyDeclaration.Initializer.Value)!;
                    }
                    else if (propertyDeclaration.ExpressionBody is not null)
                    {
                        endpointGroup.Name = GetInitializerPropertyValue<string>(context.SemanticModel.Compilation, propertyDeclaration, propertyDeclaration.ExpressionBody.Expression)!;
                    }
                    else
                    {
                        // TODO: can't resolve
                    }
                }
            }
        }

        return endpointGroup;
    }


    private static T? GetInitializerPropertyValue<T>(Compilation compilation, PropertyDeclarationSyntax? propertyDeclaration, ExpressionSyntax expression)
    {
        // Evaluate the initializer expression
        var initializerValue = compilation.GetSemanticModel(propertyDeclaration.SyntaxTree).GetConstantValue(expression);

        if (initializerValue.HasValue && initializerValue.Value is T value)
        {
            return value;
        }
        else
        {
            // TODO: warning 
            return default;
        }
    }


    private static void RegisterPostInitialization(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(async ctx =>
        {
            var httpAttriteTempate = await GetSourceFileTemplate("HttpMethodAttribute.template", null);
            string[] verbs = ["Get", "Post", "Put", "Delete"];

            foreach (var verb in verbs)
            {
                ctx.AddSource($"{verb}Attribute.g.cs", SourceText.From(httpAttriteTempate.Replace("{{METHOD}}", verb), Encoding.UTF8));
            }

            ctx.AddSource("EndpointInterfaces.g.cs", SourceText.From(await GetSourceFileTemplate("Interfaces.template", null), Encoding.UTF8));
            ctx.AddSource("EndpointAttribute.g.cs", SourceText.From(await GetSourceFileTemplate("EndpointAttribute.template", null), Encoding.UTF8));

            ctx.AddSource("MapMinimalEndpointsExtensions.g.cs", $$"""
                // <auto-generated />
                using Microsoft.AspNetCore.Builder;

                public static partial class MapMinimalEndpointsExtensions
                {
                    public static WebApplication MapMinimalEndpoints(this WebApplication app)
                    {
                        MapIndividualEndpoints(app);
                        MapEndpointGroups(app);

                        return app;
                    }

                    public static partial void MapIndividualEndpoints(this WebApplication app);

                    public static partial void MapEndpointGroups(this WebApplication app);
                } 
                """);
        });
    }


    private static async Task<string> GetSourceFileTemplate(string resourceName, string outputNamespace)
    {
        var assembly = Assembly.GetExecutingAssembly();
        string resourcePath = assembly
            .GetManifestResourceNames()
            .FirstOrDefault(e => e.Contains(resourceName));

        using Stream stream = assembly.GetManifestResourceStream(resourcePath);
        using StreamReader reader = new(stream);

        var content = await reader.ReadToEndAsync();

        // TODO: allow overriding the namespace of each source file
        return content.Replace("{{GeneratorNamespace}}", outputNamespace ?? "Nocpad.AspNetCore.MinimalEndpoints");
    }
}


record Endpoint
{
    public bool IsActive { get; set; }

    public string Template { get; set; } = string.Empty;

    public string EndpointMethod { get; set; } = string.Empty;

    public string HttpMethod { get; set; } = string.Empty;

    public EndpointNamespace Namespace { get; set; } = null!;

    public bool HasConfiguration { get; set; }

    public Group? Group { get; set; }

    public void AppenEndpointString(StringBuilder sb, string endpointParent, string variableName)
    {
        if (HasConfiguration)
        {
            sb.Append($$"""
                        var {{variableName}} = {{endpointParent}}.MapMethods("{{Template}}", new[] {"{{HttpMethod}}"}, {{Namespace}}.{{EndpointMethod}} );
                        {{Namespace}}.Configure({{variableName}});

                """);
        }
        else
        {
            sb.Append($$"""
                        var {{variableName}} = {{endpointParent}}.MapMethods("{{Template}}", new[] {"{{HttpMethod}}"}, {{Namespace}}.{{EndpointMethod}} );

                """);
        }
    }
}


record Group
{
    public EndpointNamespace Namespace { get; set; }

    public string Name { get; set; }

    public string Route { get; set; }
}


record EndpointNamespace
{
    public EndpointNamespace(INamespaceSymbol @namespace, string groupName)
    {
        Value = $"{(@namespace.IsGlobalNamespace ? "global::" : @namespace.ToDisplayString() + ".")}{groupName}";
    }

    public string Value { get; private set; }

    public override string ToString() => Value;
}